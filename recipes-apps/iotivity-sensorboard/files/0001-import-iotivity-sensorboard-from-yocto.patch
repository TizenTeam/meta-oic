From 7e3175a762cc33949f0e87b1aba320d4fbc4e59c Mon Sep 17 00:00:00 2001
From: Philippe Coval <philippe.coval@osg.samsung.com>
Date: Thu, 20 Jul 2017 15:09:40 +0200
Subject: [PATCH 1/4] import: iotivity-sensorboard from yocto

Change-Id: Ia39af355ffded77436ef184db0f3d4fb19fc131b
Signed-off-by: Philippe Coval <philippe.coval@osg.samsung.com>
---
 Makefile     |  18 +++
 namedefs.h   |  35 ++++++
 observer.cpp |  71 ++++++++++++
 observer.h   |  55 +++++++++
 sensors.h    | 111 ++++++++++++++++++
 server.cpp   | 365 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 server.h     |  71 ++++++++++++
 7 files changed, 726 insertions(+)
 create mode 100644 Makefile
 create mode 100644 namedefs.h
 create mode 100644 observer.cpp
 create mode 100644 observer.h
 create mode 100644 sensors.h
 create mode 100644 server.cpp
 create mode 100644 server.h

diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..e78b777
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,18 @@
+YOCTOCXXFLAGS=-I$(PKG_CONFIG_SYSROOT_DIR)/usr/include/iotivity/resource/ -I$(PKG_CONFIG_SYSROOT_DIR)/usr/include/iotivity/resource/stack -I$(PKG_CONFIG_SYSROOT_DIR)/usr/include/iotivity/resource/ocrandom -I$(PKG_CONFIG_SYSROOT_DIR)/usr/include/iotivity/resource/logger -I$(PKG_CONFIG_SYSROOT_DIR)/usr/include/iotivity/resource/oc_logger
+
+YOCTOLDFLAGS=-loc -loctbstack -loc_logger -lmraa
+
+all: sensorboard
+
+%.o: %.cpp
+ifeq ($(PKG_CONFIG_SYSROOT_DIR),)
+	echo "Error: Yocto cross-toolchain environment not initialized"
+	exit 1 
+endif
+	$(CXX) -std=c++0x -c -o $@ $< $(YOCTOCXXFLAGS)
+
+sensorboard: server.o observer.o
+	$(CXX) -o sensorboard server.o observer.o $(YOCTOLDFLAGS)
+
+clean:
+	rm -rf sensorboard *.o
diff --git a/namedefs.h b/namedefs.h
new file mode 100644
index 0000000..156bae4
--- /dev/null
+++ b/namedefs.h
@@ -0,0 +1,35 @@
+//******************************************************************
+//
+// Copyright 2014 Intel Corporation.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef NAMEDEFS_H_
+#define NAMEDEFS_H_
+
+#define EDISON_RESOURCE_INTERFACE "oic.if.rw"
+#define TEMPERATURE_RESOURCE_TYPE "core.temperature"
+#define LIGHT_RESOURCE_TYPE "core.light"
+#define LED_RESOURCE_TYPE "core.led"
+#define TEMPERATURE_RESOURCE_ENDPOINT "/temperature"
+#define LIGHT_RESOURCE_ENDPOINT "/ambientlight"
+#define LED_RESOURCE_ENDPOINT "/led"
+#define TEMPERATURE_RESOURCE_KEY "temperature"
+#define LIGHT_RESOURCE_KEY "ambientlight"
+#define LED_RESOURCE_KEY "switch"
+
+#endif /* NAMEDEFS_H_ */
diff --git a/observer.cpp b/observer.cpp
new file mode 100644
index 0000000..4e54ebe
--- /dev/null
+++ b/observer.cpp
@@ -0,0 +1,71 @@
+//******************************************************************
+//
+// Copyright 2014 Intel Corporation.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include "observer.h"
+
+IoTObserver::IoTObserver(IoTObserverCb Cb) :
+        m_callback(Cb), m_destroy(false), m_started(false)
+{
+    m_observerThread[0] = thread(&IoTObserver::observerThread, this);
+}
+
+IoTObserver::~IoTObserver()
+{
+    terminate();
+}
+
+void IoTObserver::start()
+{
+    if (!m_started)
+    {
+        {
+            lock_guard<mutex> lock(m_mutex);
+            m_started = true;
+        }
+        m_cond.notify_one();
+    }
+}
+
+void IoTObserver::stop()
+{
+    m_started = false;
+}
+
+void IoTObserver::terminate()
+{
+    m_destroy = true;
+    stop();
+    m_cond.notify_one();
+    m_observerThread[0].join();
+}
+
+void IoTObserver::observerThread()
+{
+    while (!m_destroy)
+    {
+        unique_lock<mutex> lock(m_mutex);
+        if (!m_started)
+            m_cond.wait(lock);
+        while (m_started)
+        {
+            m_callback();
+        }
+    }
+}
diff --git a/observer.h b/observer.h
new file mode 100644
index 0000000..8329a71
--- /dev/null
+++ b/observer.h
@@ -0,0 +1,55 @@
+//******************************************************************
+//
+// Copyright 2014 Intel Corporation.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef OBSERVER_H_
+#define OBSERVER_H_
+
+#include <iostream>
+#include <thread>
+#include <condition_variable>
+#include <mutex>
+#include <functional>
+
+using namespace std;
+
+//Polling callback function prototype.
+typedef function<void(void)> IoTObserverCb;
+
+//Hosts a polling thread which continually calls the specific function
+//supplied to its constructor. Client code simply uses Start/Stop calls
+//to kick off/suspend polling.
+class IoTObserver
+{
+    mutex m_mutex;
+    condition_variable m_cond;
+    IoTObserverCb m_callback;
+    thread m_observerThread[1];
+    bool m_destroy;
+    bool m_started;
+    void observerThread();
+    void terminate();
+public:
+    IoTObserver(IoTObserverCb Cb);
+    virtual ~IoTObserver();
+    void start();
+    void stop();
+};
+
+#endif /* OBSERVER_H_ */
diff --git a/sensors.h b/sensors.h
new file mode 100644
index 0000000..aecbf4c
--- /dev/null
+++ b/sensors.h
@@ -0,0 +1,111 @@
+//******************************************************************
+//
+// Copyright 2014 Intel Corporation.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include <stdlib.h>
+#include <math.h>
+#include "mraa.h"
+
+#define ONBOARD_LED_PIN 13
+#define TEMPERATURE_AIO_PIN 0
+#define LIGHT_SENSOR_AIO_PIN 2
+#define SAMPLE_NUM 5
+
+namespace Sensors
+{
+mraa_gpio_context led_gpio = NULL;
+mraa_aio_context tmp_aio = NULL;
+mraa_aio_context light_aio = NULL;
+
+inline void SetupPins()
+{
+    led_gpio = mraa_gpio_init(ONBOARD_LED_PIN); // Initialize pin 13
+    if (led_gpio != NULL)
+        mraa_gpio_dir(led_gpio, MRAA_GPIO_OUT); // Set direction to OUTPUT
+    tmp_aio = mraa_aio_init(TEMPERATURE_AIO_PIN);   // initialize pin 0
+    light_aio = mraa_aio_init(LIGHT_SENSOR_AIO_PIN);   // initialize pin 2
+}
+
+inline void ClosePins()
+{
+    mraa_gpio_close(led_gpio);
+    mraa_aio_close(tmp_aio);
+    mraa_aio_close(light_aio);
+}
+
+inline void SetOnboardLed(int on)
+{
+    if (led_gpio == NULL)
+    {
+        led_gpio = mraa_gpio_init(ONBOARD_LED_PIN); // Initialize pin 13
+        if (led_gpio != NULL)
+            mraa_gpio_dir(led_gpio, MRAA_GPIO_OUT); // Set direction to OUTPUT
+    }
+    if (led_gpio != NULL)
+        mraa_gpio_write(led_gpio, on); // Writes into GPIO
+}
+
+inline float GetAverageTemperatureRaw()
+{
+    if (tmp_aio == NULL)
+    {
+        tmp_aio = mraa_aio_init(TEMPERATURE_AIO_PIN); // initialize pin 0
+    }
+    
+    uint16_t adc_value = 0;
+    for (int i=0; i< SAMPLE_NUM; i++)
+        adc_value += mraa_aio_read(tmp_aio);           // read the raw value
+    
+    float average = (float)adc_value/SAMPLE_NUM;
+    cout << "Temperature reading raw ..."  << average << endl;
+    
+    return average;
+}
+
+inline float GetTemperatureInC()
+{
+    // Temperature calculation using simpilfy Steinhart-Hart equation
+    //
+    //          1/T = 1/T0 + 1/beta*ln (R/R0)
+    //
+    // where T0 = 25C room temp, R0 = 10000 ohms
+    //
+    float beta = 4090.0;            //the beta of the thermistor, magic number
+    float t_raw = GetAverageTemperatureRaw();
+    float R = 1023.0/t_raw -1;      // 
+    R = 10000.0/R;                  // 10K resistor divider circuit
+        
+    float T1 = log(R/10000.0)/beta; // natural log 
+    float T2 = T1 + 1.0/298.15;     // room temp 25C= 298.15K
+    float ret = 1.0/T2 - 273.0;
+ 
+    return ret;
+}
+
+// This function returns light level between 0 and 4095
+inline int GetLightLevel()
+{
+    uint16_t adc_value = 0;
+    if (light_aio == NULL)
+        light_aio = mraa_aio_init(LIGHT_SENSOR_AIO_PIN); // initialize pin 2
+    if (light_aio != NULL)
+        adc_value = mraa_aio_read(light_aio); // read the raw value
+    return adc_value;
+}
+}
diff --git a/server.cpp b/server.cpp
new file mode 100644
index 0000000..8308577
--- /dev/null
+++ b/server.cpp
@@ -0,0 +1,365 @@
+//******************************************************************
+//
+// Copyright 2014 Intel Corporation.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#include <signal.h>
+#include <thread>
+#include <functional>
+
+#include "server.h"
+#include "sensors.h"
+#include "namedefs.h"
+using namespace Sensors;
+
+
+void IoTServer::initializePlatform()
+{
+    cout << "Running IoTServer constructor" << endl;
+    m_platformConfig = make_shared<PlatformConfig>(ServiceType::InProc, ModeType::Server, "0.0.0.0",
+                                                   0, OC::QualityOfService::HighQos);
+    OCPlatform::Configure(*m_platformConfig);
+}
+
+IoTServer::IoTServer()
+{
+    initializePlatform();
+    setupResources();
+    m_temperatureRepresentation.setValue(TEMPERATURE_RESOURCE_KEY, (float) 0.0f);
+    m_ambientLightRepresentation.setValue(LIGHT_RESOURCE_KEY, 0);
+    m_ledRepresentation.setValue(LED_RESOURCE_KEY, 0);
+    SetupPins();
+}
+
+IoTServer::~IoTServer()
+{
+    cout << "Running IoTServer destructor" << endl;
+    ClosePins();
+}
+
+void IoTServer::setupResources()
+{
+    EntityHandler cb1 = bind(&IoTServer::temperatureEntityHandler, this, placeholders::_1);
+    createResource(TEMPERATURE_RESOURCE_ENDPOINT, TEMPERATURE_RESOURCE_TYPE, cb1,
+                   m_temperatureResource);
+    IoTObserverCb tempObsCb = bind(&IoTServer::temperatureObserverLoop, this);
+    m_temperatureObserverLoop = make_shared<IoTObserver>(tempObsCb);
+
+    EntityHandler cb2 = bind(&IoTServer::lightEntityHandler, this, placeholders::_1);
+    createResource(LIGHT_RESOURCE_ENDPOINT, LIGHT_RESOURCE_TYPE, cb2, m_ambientLightResource);
+    IoTObserverCb lightObsCb = bind(&IoTServer::lightObserverLoop, this);
+    m_ambientLightObserverLoop = make_shared<IoTObserver>(lightObsCb);
+
+    EntityHandler cb3 = bind(&IoTServer::LEDEntityHandler, this, placeholders::_1);
+    createResource(LED_RESOURCE_ENDPOINT, LED_RESOURCE_TYPE, cb3, m_ledResource);
+}
+
+void IoTServer::createResource(string Uri, string Type, EntityHandler Cb, OCResourceHandle& Handle)
+{
+    string resourceUri = Uri;
+    string resourceType = Type;
+    string resourceInterface = EDISON_RESOURCE_INTERFACE;
+    uint8_t resourceFlag = OC_DISCOVERABLE | OC_OBSERVABLE;
+
+    OCStackResult result = OCPlatform::registerResource(Handle, resourceUri, resourceType,
+                                                        resourceInterface, Cb, resourceFlag);
+
+    if (result != OC_STACK_OK)
+        cerr << "Could not create " << Type << " resource" << endl;
+    else
+        cout << "Successfully created " << Type << " resource" << endl;
+}
+
+void IoTServer::putLEDRepresentation()
+{
+    int state = 0;
+    m_ledRepresentation.getValue(LED_RESOURCE_KEY, state);
+    SetOnboardLed(state);
+    if (state == 0)
+        cout << "Turned off LED" << endl;
+    else if (state == 1)
+        cout << "Turned on LED" << endl;
+    else
+        cerr << "Invalid request value" << endl;
+}
+
+OCRepresentation IoTServer::getLEDRepresentation()
+{
+    return m_ledRepresentation;
+}
+
+void IoTServer::temperatureObserverLoop()
+{
+    usleep(1500000);
+    cout << "Temperature Observer Callback" << endl;
+    shared_ptr<OCResourceResponse> resourceResponse(new OCResourceResponse());
+    resourceResponse->setErrorCode(200);
+    resourceResponse->setResourceRepresentation(getTemperatureRepresentation(),
+    EDISON_RESOURCE_INTERFACE);
+    OCStackResult result = OCPlatform::notifyListOfObservers(m_temperatureResource,
+                                                             m_temperatureObservers,
+                                                             resourceResponse);
+    if (result == OC_STACK_NO_OBSERVERS)
+    {
+        cout << "No more observers..Stopping observer loop..." << endl;
+        m_temperatureObserverLoop->stop();
+    }
+}
+
+void IoTServer::lightObserverLoop()
+{
+    usleep(1500000);
+    cout << "Light Observer Callback" << endl;
+    shared_ptr<OCResourceResponse> resourceResponse(new OCResourceResponse());
+    resourceResponse->setErrorCode(200);
+    resourceResponse->setResourceRepresentation(getLightRepresentation(),
+    EDISON_RESOURCE_INTERFACE);
+    OCStackResult result = OCPlatform::notifyListOfObservers(m_ambientLightResource,
+                                                             m_ambientLightObservers,
+                                                             resourceResponse);
+    if (result == OC_STACK_NO_OBSERVERS)
+    {
+        cout << "No more observers..Stopping observer loop..." << endl;
+        m_ambientLightObserverLoop->stop();
+    }
+}
+
+OCRepresentation IoTServer::getTemperatureRepresentation()
+{
+    m_temperatureRepresentation.setValue(TEMPERATURE_RESOURCE_KEY, GetTemperatureInC());
+    return m_temperatureRepresentation;
+}
+
+OCRepresentation IoTServer::getLightRepresentation()
+{
+    m_ambientLightRepresentation.setValue(LIGHT_RESOURCE_KEY, GetLightLevel());
+    return m_ambientLightRepresentation;
+}
+
+OCEntityHandlerResult IoTServer::lightEntityHandler(shared_ptr<OCResourceRequest> Request)
+{
+    OCEntityHandlerResult result = OC_EH_ERROR;
+    if (Request)
+    {
+        string requestType = Request->getRequestType();
+        int requestFlag = Request->getRequestHandlerFlag();
+        if (requestFlag & RequestHandlerFlag::RequestFlag)
+        {
+            auto Response = std::make_shared<OC::OCResourceResponse>();
+            Response->setRequestHandle(Request->getRequestHandle());
+            Response->setResourceHandle(Request->getResourceHandle());
+            if (requestType == "GET")
+            {
+                cout << "GET request for ambient light reading" << endl;
+                if (Response)
+                {
+                    Response->setErrorCode(200);
+                    Response->setResponseResult(OC_EH_OK);
+                    Response->setResourceRepresentation(getLightRepresentation());
+                    if (OCPlatform::sendResponse(Response) == OC_STACK_OK)
+                    {
+                        result = OC_EH_OK;
+                    }
+                }
+            }
+            else
+            {
+                Response->setResponseResult(OC_EH_ERROR);
+                OCPlatform::sendResponse(Response);
+                cerr << "Unsupported request type" << endl;
+                return result;
+            }
+        }
+        if (requestFlag & RequestHandlerFlag::ObserverFlag)
+        {
+            ObservationInfo observationInfo = Request->getObservationInfo();
+            if (ObserveAction::ObserveRegister == observationInfo.action)
+            {
+                cout << "Starting observer for ambient light sensor" << endl;
+                m_ambientLightObservers.push_back(observationInfo.obsId);
+                m_ambientLightObserverLoop->start();
+            }
+            else if (ObserveAction::ObserveUnregister == observationInfo.action)
+            {
+                cout << "Stopping observer for ambient light sensor" << endl;
+                m_ambientLightObservers.erase(
+                        remove(m_ambientLightObservers.begin(), m_ambientLightObservers.end(),
+                               observationInfo.obsId),
+                        m_ambientLightObservers.end());
+                m_ambientLightObserverLoop->stop();
+            }
+        }
+    }
+    return result;
+}
+
+OCEntityHandlerResult IoTServer::temperatureEntityHandler(shared_ptr<OCResourceRequest> Request)
+{
+    OCEntityHandlerResult result = OC_EH_ERROR;
+    if (Request)
+    {
+        string requestType = Request->getRequestType();
+        int requestFlag = Request->getRequestHandlerFlag();
+        if (requestFlag & RequestHandlerFlag::RequestFlag)
+        {
+            auto Response = std::make_shared<OC::OCResourceResponse>();
+            Response->setRequestHandle(Request->getRequestHandle());
+            Response->setResourceHandle(Request->getResourceHandle());
+            if (requestType == "GET")
+            {
+                cout << "GET request for temperature sensor reading" << endl;
+                if (Response)
+                {
+                    Response->setErrorCode(200);
+                    Response->setResponseResult(OC_EH_OK);
+                    Response->setResourceRepresentation(getTemperatureRepresentation());
+                    if (OCPlatform::sendResponse(Response) == OC_STACK_OK)
+                    {
+                        result = OC_EH_OK;
+                    }
+                }
+            }
+            else
+            {
+                Response->setResponseResult(OC_EH_ERROR);
+                OCPlatform::sendResponse(Response);
+                cerr << "Unsupported request type" << endl;
+                return result;
+            }
+        }
+        if (requestFlag & RequestHandlerFlag::ObserverFlag)
+        {
+            ObservationInfo observationInfo = Request->getObservationInfo();
+            if (ObserveAction::ObserveRegister == observationInfo.action)
+            {
+                cout << "Starting observer for temperature sensor" << endl;
+                m_temperatureObservers.push_back(observationInfo.obsId);
+                m_temperatureObserverLoop->start();
+            }
+            else if (ObserveAction::ObserveUnregister == observationInfo.action)
+            {
+                cout << "Stopping observer for temperature sensor" << endl;
+                m_temperatureObservers.erase(
+                        remove(m_temperatureObservers.begin(), m_temperatureObservers.end(),
+                               observationInfo.obsId),
+                        m_temperatureObservers.end());
+                m_temperatureObserverLoop->stop();
+            }
+        }
+    }
+    return result;
+}
+
+OCEntityHandlerResult IoTServer::LEDEntityHandler(shared_ptr<OCResourceRequest> Request)
+{
+    OCEntityHandlerResult result = OC_EH_ERROR;
+    if (Request)
+    {
+        string requestType = Request->getRequestType();
+        int requestFlag = Request->getRequestHandlerFlag();
+        if (requestFlag & RequestHandlerFlag::RequestFlag)
+        {
+            auto Response = std::make_shared<OC::OCResourceResponse>();
+            Response->setRequestHandle(Request->getRequestHandle());
+            Response->setResourceHandle(Request->getResourceHandle());
+            if (requestType == "PUT")
+            {
+                cout << "PUT request for platform LED" << endl;
+                OCRepresentation requestRep = Request->getResourceRepresentation();
+                if (requestRep.hasAttribute(LED_RESOURCE_KEY))
+                {
+                    try
+                    {
+                        requestRep.getValue<int>(LED_RESOURCE_KEY);
+                    }
+                    catch (...)
+                    {
+                        Response->setResponseResult(OC_EH_ERROR);
+                        OCPlatform::sendResponse(Response);
+                        cerr << "Client sent invalid resource value type" << endl;
+                        return result;
+                    }
+                }
+                else
+                {
+                    Response->setResponseResult(OC_EH_ERROR);
+                    OCPlatform::sendResponse(Response);
+                    cerr << "Client sent invalid resource key" << endl;
+                    return result;
+                }
+                m_ledRepresentation = requestRep;
+                putLEDRepresentation();
+                if (Response)
+                {
+                    Response->setErrorCode(200);
+                    Response->setResourceRepresentation(getLEDRepresentation());
+                    Response->setResponseResult(OC_EH_OK);
+                    if (OCPlatform::sendResponse(Response) == OC_STACK_OK)
+                    {
+                        result = OC_EH_OK;
+                    }
+                }
+            }
+            else if (requestType == "GET")
+            {
+                cout << "GET request for platform LED" << endl;
+                if (Response)
+                {
+                    Response->setErrorCode(200);
+                    Response->setResourceRepresentation(getLEDRepresentation());
+                    Response->setResponseResult(OC_EH_OK);
+                    if (OCPlatform::sendResponse(Response) == OC_STACK_OK)
+                    {
+                        result = OC_EH_OK;
+                    }
+                }
+            }
+            else
+            {
+                Response->setResponseResult(OC_EH_ERROR);
+                OCPlatform::sendResponse(Response);
+                cerr << "Unsupported request type" << endl;
+            }
+        }
+    }
+    return result;
+}
+
+int quit = 0;
+
+void handle_signal(int signal)
+{
+    quit = 1;
+}
+
+int main()
+{
+    struct sigaction sa;
+    sigfillset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = handle_signal;
+    sigaction(SIGINT, &sa, NULL);
+    cout << "Press Ctrl-C to quit...." << endl;
+    IoTServer server;
+    do
+    {
+        usleep(2000000);
+    }
+    while (quit != 1);
+    return 0;
+}
+
diff --git a/server.h b/server.h
new file mode 100644
index 0000000..b77325d
--- /dev/null
+++ b/server.h
@@ -0,0 +1,71 @@
+//******************************************************************
+//
+// Copyright 2014 Intel Corporation.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#ifndef SERVER_H_
+#define SERVER_H_
+
+#include <string>
+#include <iostream>
+#include <memory>
+#include "ocstack.h"
+#include "observer.h"
+#include "OCPlatform.h"
+#include "OCApi.h"
+
+using namespace std;
+using namespace OC;
+
+class IoTServer
+{
+    shared_ptr<PlatformConfig> m_platformConfig;
+    OCRepresentation m_temperatureRepresentation;
+    OCResourceHandle m_temperatureResource;
+    OCRepresentation m_ambientLightRepresentation;
+    OCResourceHandle m_ambientLightResource;
+    OCRepresentation m_ledRepresentation;
+    OCResourceHandle m_ledResource;
+    ObservationIds m_ambientLightObservers;
+    ObservationIds m_temperatureObservers;
+    shared_ptr<IoTObserver> m_ambientLightObserverLoop;
+    shared_ptr<IoTObserver> m_temperatureObserverLoop;
+
+    void initializePlatform();
+    void setupResources();
+    void createResource(string, string, EntityHandler, OCResourceHandle&);
+
+    OCRepresentation getTemperatureRepresentation();
+    OCRepresentation getLightRepresentation();
+    OCRepresentation getLEDRepresentation();
+    void putLEDRepresentation();
+
+    //Polling threads to periodically query sensor values and notify
+    //subscribers.
+    void temperatureObserverLoop();
+    void lightObserverLoop();
+
+    OCEntityHandlerResult temperatureEntityHandler(shared_ptr<OCResourceRequest>);
+    OCEntityHandlerResult lightEntityHandler(shared_ptr<OCResourceRequest>);
+    OCEntityHandlerResult LEDEntityHandler(shared_ptr<OCResourceRequest>);
+public:
+    IoTServer();
+    virtual ~IoTServer();
+};
+
+#endif /* SERVER_H_ */
-- 
1.9.1

